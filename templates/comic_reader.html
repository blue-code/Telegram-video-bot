<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>{{ title }} - ë§Œí™”ì±… ë·°ì–´</title>
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#1a1a1a">
    <script src="/static/bookmarks-series.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a1a;
            color: #ccc;
            font-family: sans-serif;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* Comic Mode (Page-based) */
        #viewer.comic-mode {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        #viewer.comic-mode #page-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: opacity 0.3s;
        }

        /* Webtoon Mode Active Body State - FORCE SCROLL */
        html.webtoon-mode-active,
        body.webtoon-mode-active {
            margin: 0;
            padding: 0;
            overflow-y: auto !important; /* Force browser scroll */
            overflow-x: hidden;
            height: auto !important; /* Remove 100vh limit */
            -webkit-overflow-scrolling: touch;
        }
        
        body.webtoon-mode-active #viewer.webtoon-mode {
            position: relative;
            width: 100%;
            height: auto !important;
            overflow: visible !important;
            min-height: 100vh;
            background: #000;
            z-index: 1;
        }

        /* Ensure container takes full space */
        body.webtoon-mode-active #webtoon-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: auto;
            overflow: visible;
        }

        #webtoon-container {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 0;
            width: 100%;
        }

        #viewer.webtoon-mode #webtoon-container {
            display: flex;
        }

        .webtoon-page {
            width: 100%;
            max-width: 800px; /* Limit max width for readability on large screens? Or 100%? User asked for seamless. */
            /* User didn't ask for max width limitation, but usually webtoons are full width on mobile. */
            /* Let's keep max-width: 100% effectively. */
            max-width: 100%; 
            display: block;
            margin: 0;
            padding: 0;
            border: none;
            font-size: 0; /* Remove whitespace gaps */
            line-height: 0;
        }

        .webtoon-page img {
            width: 100%;
            height: auto;
            display: block;
            border: none;
            margin: 0;
            padding: 0;
        }

        .webtoon-loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* Page Image (Comic Mode only) */
        #page-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: opacity 0.3s;
            display: block;
        }

        #viewer.webtoon-mode #page-image {
            display: none;
        }

        .loading {
            opacity: 0.5;
        }

        /* Loading Spinner */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
            display: none;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: #667eea;
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* Touch Zones (Comic Mode only) */
        .touch-zone {
            position: absolute;
            top: 0; bottom: 0;
            z-index: 5;
            display: block;
        }

        /* 
           Note: .touch-zone is sibling of #viewer, not child.
           The previous CSS selector #viewer.webtoon-mode .touch-zone was incorrect.
           We will handle display in JS or use specific classes on body/container.
        */

        #prev-zone { left: 0; width: 30%; }
        #next-zone { right: 0; width: 30%; }
        
        /* Menu Zone - ìƒë‹¨ ì¤‘ì•™ìœ¼ë¡œ ì¶•ì†Œ (ìŠ¤í¬ë¡¤ ë°©í•´ ìµœì†Œí™”) */
        #menu-zone { 
            left: 30%; width: 40%; 
            top: 0; height: 20%; /* ìƒë‹¨ 20% ì˜ì—­ë§Œ í„°ì¹˜ ì˜ì—­ìœ¼ë¡œ ì„¤ì • */
            bottom: auto;
        }

        /* Double-tap overlay */
        .double-tap-overlay {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(102, 126, 234, 0.9);
            color: #fff;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            display: none;
            z-index: 100;
        }

        /* Top Controls */
        #controls {
            position: fixed;
            top: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            transform: translateY(-100%);
            transition: transform 0.3s;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #controls.active {
            transform: translateY(0);
        }

        .back-btn {
            background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;
            text-decoration: none; display: flex; align-items: center; gap: 5px;
        }

        .title-text {
            font-size: 14px; font-weight: 600; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap;
            flex: 1; text-align: center;
        }

        .settings-btn {
            background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;
        }

        .download-btn {
            background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;
            margin-right: 10px;
        }

        .favorite-btn {
            background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;
            margin-right: 10px;
        }

        .favorite-btn.active {
            color: #f59e0b;
        }

        /* Bottom Settings Panel */
        .settings-panel {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.95);
            padding: 20px;
            transform: translateY(100%);
            transition: transform 0.3s;
            z-index: 20;
            border-top: 1px solid #333;
            max-height: 70vh;
            overflow-y: auto;
        }
        .settings-panel.active {
            transform: translateY(0);
        }

        .setting-group { margin-bottom: 15px; }
        .setting-label {
            font-size: 12px; color: #888; margin-bottom: 8px;
            display: block;
        }

        .option-buttons {
            display: flex; gap: 10px;
        }
        .option-btn {
            flex: 1; padding: 10px; border: 1px solid #444;
            border-radius: 6px; cursor: pointer; text-align: center;
            font-size: 14px; background: #222; color: #fff;
            transition: all 0.3s;
        }
        .option-btn.active {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.2);
        }

        /* Progress Bar */
        #progress-bar-container {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 4px;
            background: rgba(255,255,255,0.1);
            z-index: 10;
        }
        #progress-bar {
            height: 100%;
            background: #667eea;
            width: 0%;
            transition: width 0.2s;
        }

        /* Page Info */
        #page-info {
            position: fixed;
            bottom: 10px; right: 10px;
            font-size: 12px; color: #888;
            pointer-events: none; z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Pinch Zoom Support */
        #viewer.zoomed #page-image {
            cursor: move;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
    </div>

    <!-- Viewer Container -->
    <div id="viewer" class="comic-mode">
        <!-- Comic Mode: Single Page -->
        <img id="page-image" src="" alt="Comic Page">

        <!-- Webtoon Mode: Scrollable Pages -->
        <div id="webtoon-container">
            <!-- Pages will be dynamically loaded here -->
        </div>
    </div>

    <!-- Touch Zones (Comic Mode only) -->
    <div id="prev-zone" class="touch-zone"></div>
    <div id="menu-zone" class="touch-zone"></div>
    <div id="next-zone" class="touch-zone"></div>

    <!-- Double-tap overlay -->
    <div class="double-tap-overlay" id="double-tap-message">ë‹¤ìŒ ë§Œí™”ì±…ìœ¼ë¡œ ì´ë™</div>

    <!-- Top Controls -->
    <div id="controls">
        <a href="/comics/{{ user_id }}" class="back-btn">â† ë’¤ë¡œ</a>
        <span class="title-text">{{ title }}</span>
        <button class="favorite-btn" onclick="toggleFavorite()" id="favorite-btn" title="ì¦ê²¨ì°¾ê¸°">
            â˜†
        </button>
        <button class="favorite-btn" onclick="toggleComicCompletion()" id="completion-btn" title="ì™„ë£Œ í‘œì‹œ">
            âœ“
        </button>
        <button class="favorite-btn" onclick="addBookmarkClick()" id="bookmark-btn" title="ë¶ë§ˆí¬">
            ğŸ“‘
        </button>
        <button class="favorite-btn" onclick="showSeriesModal()" id="series-btn" title="ì‹œë¦¬ì¦ˆ ì¶”ê°€">
            ğŸ“š
        </button>
        <button class="download-btn" onclick="downloadComic()" title="ë‹¤ìš´ë¡œë“œ">
            â¬‡ï¸
        </button>
        <button class="settings-btn" onclick="toggleSettings()">âš™ï¸</button>
    </div>

    <!-- Bottom Settings -->
    <div class="settings-panel" id="settings">
        <div class="setting-group">
            <span class="setting-label">ì½ê¸° ë°©í–¥ (ë§Œí™”ì±… ëª¨ë“œ)</span>
            <div class="option-buttons">
                <div class="option-btn" onclick="setReadingDirection('ltr')" id="dir-ltr">
                    ì¼ë°˜ (ì™¼ìª½â†’ì˜¤ë¥¸ìª½)
                </div>
                <div class="option-btn" onclick="setReadingDirection('rtl')" id="dir-rtl">
                    ì¼ë³¸ì‹ (ì˜¤ë¥¸ìª½â†’ì™¼ìª½)
                </div>
            </div>
        </div>
        <div class="setting-group">
            <span class="setting-label">ë³´ê¸° ëª¨ë“œ</span>
            <div class="option-buttons">
                <div class="option-btn active" onclick="setMode('comic')" id="mode-comic">
                    ë§Œí™”ì±… (í˜ì´ì§€)
                </div>
                <div class="option-btn" onclick="setMode('webtoon')" id="mode-webtoon">
                    ì›¹íˆ° (ìŠ¤í¬ë¡¤)
                </div>
            </div>
        </div>
        <div class="setting-group">
            <span class="setting-label">ì´ì¤‘ í˜ì´ì§€ ìë™ ë¶„í•  (ì„¸ë¡œ í™”ë©´)</span>
            <div class="option-buttons">
                <div class="option-btn active" onclick="setAutoSplit(true)" id="split-on">
                    ì¼œê¸° (ê¶Œì¥)
                </div>
                <div class="option-btn" onclick="setAutoSplit(false)" id="split-off">
                    ë„ê¸°
                </div>
            </div>
        </div>
    </div>

    <!-- Bookmarks Panel -->
    <div class="settings-panel" id="bookmarks-panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0;">ğŸ“‘ ë¶ë§ˆí¬</h3>
            <button onclick="toggleBookmarksPanel()" style="background: none; border: none; color: #fff; font-size: 24px; cursor: pointer;">âœ•</button>
        </div>
        <div id="bookmarks-list" style="max-height: 50vh; overflow-y: auto;">
            <p style="color: #888; text-align: center;">ë¶ë§ˆí¬ë¥¼ ë¡œë”© ì¤‘...</p>
        </div>
    </div>

    <div id="progress-bar-container"><div id="progress-bar"></div></div>
    <div id="page-info"></div>

    <script>
        const fileId = {{ file_id }};
        const userId = {{ user_id }};
        const pageCount = {{ page_count }};
        const seriesName = {{ series|tojson|safe }}; // ì‹œë¦¬ì¦ˆëª… (JSON ì•ˆì „ ë³€í™˜)
        
        // ì„œë²„ì—ì„œ ì „ë‹¬ë°›ì€ ì„¤ì • (í•´ë‹¹ íŒŒì¼ì— ì €ì¥ëœ ì§„í–‰ ì •ë³´)
        const serverSettings = {{ settings|safe }};

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì‹œë¦¬ì¦ˆë³„ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
        const storageKey = `comic_settings_${seriesName}`;
        let localSettings = {};
        try {
            const stored = localStorage.getItem(storageKey);
            if (stored) localSettings = JSON.parse(stored);
        } catch (e) { console.error("LocalStorage error", e); }

        // ì„¤ì • ìš°ì„ ìˆœìœ„: ë¡œì»¬ ìŠ¤í† ë¦¬ì§€(ìµœì‹  ì‹œë¦¬ì¦ˆ ì„¤ì •) > ì„œë²„ ì„¤ì •(íŒŒì¼ë³„ ì €ì¥ë¨) > ê¸°ë³¸ê°’
        // ë‹¨, ì„œë²„ ì„¤ì •ì´ ì¡´ì¬í•˜ê³  ìœ íš¨í•˜ë‹¤ë©´(ì¦‰, ì´ì „ì— ì´ íŒŒì¼ì„ ì½ì€ ì ì´ ìˆë‹¤ë©´) ì„œë²„ ì„¤ì •ì„ ì¡´ì¤‘í•  ìˆ˜ë„ ìˆìœ¼ë‚˜,
        // ì‚¬ìš©ìëŠ” 'ì‹œë¦¬ì¦ˆ ì„¤ì • ìœ ì§€'ë¥¼ ì›í•˜ë¯€ë¡œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ë¥¼ ìš°ì„ í•©ë‹ˆë‹¤.
        // ë‹¤ë§Œ, í˜ì´ì§€ ì •ë³´ëŠ” íŒŒì¼ë³„ë¡œ ë‹¤ë¥´ë¯€ë¡œ ì„¤ì •(ëª¨ë“œ/ë°©í–¥)ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤.
        
        let currentPage = {{ current_page }};
        let readingDirection = localSettings.reading_direction || serverSettings.reading_direction || 'ltr';
        let mode = localSettings.mode || serverSettings.mode || 'comic';
        let autoSplitEnabled = (localSettings.auto_split !== undefined) ? localSettings.auto_split : (serverSettings.auto_split !== false);
        let isFavorite = false;

        const pageImg = document.getElementById('page-image');
        const loading = document.getElementById('loading');
        const progressBar = document.getElementById('progress-bar');
        const pageInfo = document.getElementById('page-info');
        const viewer = document.getElementById('viewer');
        const webtoonContainer = document.getElementById('webtoon-container');

        // Webtoon mode variables
        let webtoonLoadedPages = [];
        let webtoonLoading = false;
        let webtoonCurrentPage = 0;

        // Double-page spread variables
        let isDoublePage = false;
        let currentSplit = 0; // 0: left/first, 1: right/second
        let splitImages = { left: null, right: null };
        let originalImageData = null;

        // Initialize
        if (mode === 'webtoon') {
            initWebtoonMode();
        } else {
            loadPage(currentPage);
        }
        applySettings();
        loadFavoriteStatus();

        // Navigation (Comic Mode)
        document.getElementById('prev-zone').addEventListener('click', prevPage);
        document.getElementById('next-zone').addEventListener('click', nextPage);
        document.getElementById('menu-zone').addEventListener('click', toggleMenu);

        // Double-tap to next comic
        let lastTap = 0;
        document.getElementById('menu-zone').addEventListener('dblclick', () => {
            navigateToNextComic();
        });

        // Keyboard support
        document.addEventListener('keyup', (e) => {
            if (mode === 'comic') {
                if (e.key === 'ArrowLeft') {
                    if (readingDirection === 'rtl') nextPage();
                    else prevPage();
                }
                if (e.key === 'ArrowRight') {
                    if (readingDirection === 'rtl') prevPage();
                    else nextPage();
                }
            }
        });

        // ========== COMIC MODE FUNCTIONS ==========

        function loadPage(pageNum, forceSplit = null) {
            if (pageNum < 0 || pageNum >= pageCount) return;

            loading.style.display = 'block';
            pageImg.classList.add('loading');

            const pageUrl = `/api/comics/page/${fileId}/${pageNum}`;

            fetch(pageUrl)
                .then(response => {
                    if (!response.ok) throw new Error('Failed to load page');
                    return response.blob();
                })
                .then(blob => {
                    const url = URL.createObjectURL(blob);
                    const img = new Image();

                    img.onload = () => {
                        // ì´ë¯¸ì§€ ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨ í™•ì¸
                        const imgRatio = img.width / img.height;
                        const isLandscape = imgRatio > 1.5; // ê°€ë¡œê°€ ì„¸ë¡œì˜ 1.5ë°° ì´ìƒì´ë©´ ì´ì¤‘ í˜ì´ì§€

                        // í™”ë©´ ë°©í–¥ í™•ì¸
                        const viewportRatio = window.innerWidth / window.innerHeight;
                        const isPortraitScreen = viewportRatio < 1;

                        // ì´ì¤‘ í˜ì´ì§€ íŒë‹¨: ì´ë¯¸ì§€ê°€ ê°€ë¡œí˜• && í™”ë©´ì´ ì„¸ë¡œí˜• && ìë™ ë¶„í•  í™œì„±í™”
                        isDoublePage = autoSplitEnabled && isLandscape && isPortraitScreen;

                        if (isDoublePage) {
                            // ì´ë¯¸ì§€ë¥¼ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê¸°
                            splitDoublePage(img, url);

                            // forceSplitì´ ëª…ì‹œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì½ê¸° ë°©í–¥ì— ë”°ë¼ ê²°ì •
                            if (forceSplit === null) {
                                currentSplit = (readingDirection === 'rtl') ? 1 : 0;
                            } else {
                                currentSplit = forceSplit;
                            }

                            // í•´ë‹¹ ë¶„í•  í˜ì´ì§€ í‘œì‹œ
                            displaySplitPage();
                        } else {
                            // ì¼ë°˜ í˜ì´ì§€ í‘œì‹œ
                            isDoublePage = false;
                            currentSplit = 0;
                            pageImg.src = url;
                            pageImg.onload = () => {
                                loading.style.display = 'none';
                                pageImg.classList.remove('loading');
                            };
                        }

                        currentPage = pageNum;
                        updateProgress();
                        saveProgress();
                    };

                    img.src = url;
                    originalImageData = url;
                })
                .catch(err => {
                    console.error('Error loading page:', err);
                    loading.style.display = 'none';
                    pageImg.classList.remove('loading');
                });
        }

        function splitDoublePage(img, originalUrl) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const halfWidth = img.width / 2;
            canvas.width = halfWidth;
            canvas.height = img.height;

            // ì™¼ìª½ í˜ì´ì§€
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, halfWidth, img.height, 0, 0, halfWidth, img.height);
            splitImages.left = canvas.toDataURL();

            // ì˜¤ë¥¸ìª½ í˜ì´ì§€
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, halfWidth, 0, halfWidth, img.height, 0, 0, halfWidth, img.height);
            splitImages.right = canvas.toDataURL();

            console.log('Double-page spread detected and split');
        }

        function displaySplitPage() {
            const splitUrl = (currentSplit === 0) ? splitImages.left : splitImages.right;
            pageImg.src = splitUrl;
            pageImg.onload = () => {
                loading.style.display = 'none';
                pageImg.classList.remove('loading');
            };

            // í˜ì´ì§€ ì •ë³´ ì—…ë°ì´íŠ¸
            updatePageInfo();
        }

        function updatePageInfo() {
            if (isDoublePage) {
                const side = (readingDirection === 'rtl')
                    ? (currentSplit === 1 ? 'ìš°' : 'ì¢Œ')
                    : (currentSplit === 0 ? 'ì¢Œ' : 'ìš°');
                pageInfo.textContent = `${currentPage + 1}/${pageCount} (${side})`;
            } else {
                pageInfo.textContent = `${currentPage + 1} / ${pageCount}`;
            }
        }

        function prevPage() {
            // ì´ì¤‘ í˜ì´ì§€ ì²˜ë¦¬
            if (isDoublePage) {
                if (readingDirection === 'rtl') {
                    // RTL: ì˜¤ë¥¸ìª½â†’ì™¼ìª½ ìˆœì„œ
                    if (currentSplit === 1) {
                        // ì˜¤ë¥¸ìª½ í˜ì´ì§€ â†’ ì™¼ìª½ í˜ì´ì§€ë¡œ
                        currentSplit = 0;
                        displaySplitPage();
                        return;
                    }
                    // ì™¼ìª½ í˜ì´ì§€ â†’ ë‹¤ìŒ ì‹¤ì œ í˜ì´ì§€ë¡œ
                } else {
                    // LTR: ì™¼ìª½â†’ì˜¤ë¥¸ìª½ ìˆœì„œ
                    if (currentSplit === 1) {
                        // ì˜¤ë¥¸ìª½ í˜ì´ì§€ â†’ ì™¼ìª½ í˜ì´ì§€ë¡œ
                        currentSplit = 0;
                        displaySplitPage();
                        return;
                    }
                    // ì™¼ìª½ í˜ì´ì§€ â†’ ì´ì „ ì‹¤ì œ í˜ì´ì§€ë¡œ
                }
            }

            // ì‹¤ì œ í˜ì´ì§€ ì´ë™
            if (readingDirection === 'rtl') {
                // RTL: right = prev
                if (currentPage < pageCount - 1) {
                    loadPage(currentPage + 1);
                }
            } else {
                // LTR: left = prev
                if (currentPage > 0) {
                    loadPage(currentPage - 1);
                } else {
                    // At first page, try to go to previous comic
                    navigateToPreviousComic();
                }
            }
        }

        function nextPage() {
            // ì´ì¤‘ í˜ì´ì§€ ì²˜ë¦¬
            if (isDoublePage) {
                if (readingDirection === 'rtl') {
                    // RTL: ì˜¤ë¥¸ìª½â†’ì™¼ìª½ ìˆœì„œ
                    if (currentSplit === 1) {
                        // ì˜¤ë¥¸ìª½ í˜ì´ì§€ â†’ ì™¼ìª½ í˜ì´ì§€ë¡œ
                        currentSplit = 0;
                        displaySplitPage();
                        return;
                    }
                    // ì™¼ìª½ í˜ì´ì§€ â†’ ì´ì „ ì‹¤ì œ í˜ì´ì§€ë¡œ (RTLì´ë¯€ë¡œ)
                } else {
                    // LTR: ì™¼ìª½â†’ì˜¤ë¥¸ìª½ ìˆœì„œ
                    if (currentSplit === 0) {
                        // ì™¼ìª½ í˜ì´ì§€ â†’ ì˜¤ë¥¸ìª½ í˜ì´ì§€ë¡œ
                        currentSplit = 1;
                        displaySplitPage();
                        return;
                    }
                    // ì˜¤ë¥¸ìª½ í˜ì´ì§€ â†’ ë‹¤ìŒ ì‹¤ì œ í˜ì´ì§€ë¡œ
                }
            }

            // ì‹¤ì œ í˜ì´ì§€ ì´ë™
            if (readingDirection === 'rtl') {
                // RTL: left = next
                if (currentPage > 0) {
                    loadPage(currentPage - 1);
                } else {
                    // At last page (in RTL, page 0), try to go to next comic
                    navigateToNextComic();
                }
            } else {
                // LTR: right = next
                if (currentPage < pageCount - 1) {
                    loadPage(currentPage + 1);
                } else {
                    // At last page, try to go to next comic
                    navigateToNextComic();
                }
            }
        }

        // ========== WEBTOON MODE FUNCTIONS ==========

        function initWebtoonMode() {
            webtoonContainer.innerHTML = '';
            webtoonLoadedPages = [];
            webtoonCurrentPage = currentPage;

            // Load initial batch of pages
            loadWebtoonPages(currentPage, Math.min(currentPage + 5, pageCount));

            // Setup infinite scroll (Window scroll for body)
            window.removeEventListener('scroll', handleWebtoonScroll);
            window.addEventListener('scroll', handleWebtoonScroll);
        }

        function loadWebtoonPages(startPage, endPage) {
            if (webtoonLoading) return;

            webtoonLoading = true;

            for (let i = startPage; i < endPage; i++) {
                if (webtoonLoadedPages.includes(i)) continue;

                const pageDiv = document.createElement('div');
                pageDiv.className = 'webtoon-page';
                pageDiv.dataset.page = i;
                
                // Add placeholder height to prevent scroll jank
                pageDiv.style.minHeight = '200px'; 

                const img = document.createElement('img');
                img.dataset.src = `/api/comics/page/${fileId}/${i}`;
                img.alt = `Page ${i + 1}`;
                img.loading = 'lazy';

                // Use Intersection Observer for lazy loading
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            img.src = img.dataset.src;
                            // Remove min-height once loaded to fit content
                            img.onload = () => {
                                img.parentElement.style.minHeight = 'auto';
                            };
                            observer.unobserve(img);
                        }
                    });
                });

                observer.observe(img);

                pageDiv.appendChild(img);
                webtoonContainer.appendChild(pageDiv);

                webtoonLoadedPages.push(i);
            }

            // Add loading indicator at the end if more pages exist
            if (endPage < pageCount) {
                // Remove existing loader first to move it to bottom
                const existingLoader = document.getElementById('webtoon-end-loading');
                if (existingLoader) existingLoader.remove();

                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'webtoon-loading';
                loadingDiv.id = 'webtoon-end-loading';
                loadingDiv.textContent = 'í˜ì´ì§€ ë¡œë”© ì¤‘...';
                webtoonContainer.appendChild(loadingDiv);
            } else {
                const endDiv = document.createElement('div');
                endDiv.className = 'webtoon-loading';
                endDiv.innerHTML = '<button onclick="navigateToNextComic()" style="padding: 15px 30px; background: #667eea; color: #fff; border: none; border-radius: 8px; font-size: 16px; cursor: pointer;">ë‹¤ìŒ ë§Œí™”ì±… â†’</button>';
                webtoonContainer.appendChild(endDiv);
            }

            webtoonLoading = false;
        }

        function handleWebtoonScroll() {
            // Use window scroll properties
            const scrollTop = window.scrollY || document.documentElement.scrollTop;
            const scrollHeight = document.documentElement.scrollHeight;
            const clientHeight = window.innerHeight;

            // Update current page based on scroll position
            const pages = document.querySelectorAll('.webtoon-page');
            // Optimization: Only check visible pages or use IntersectionObserver for tracking current page?
            // For now, iterate but optimize loop break?
            // Let's keep existing logic but be mindful of performance
            
            // Find center-most page
            let centerPage = null;
            const viewCenter = scrollTop + (clientHeight / 2);
            
            for (const page of pages) {
                const rect = page.getBoundingClientRect(); // Relative to viewport
                // rect.top + scrollTop is absolute top.
                // Simpler: Check if page covers center of viewport
                if (rect.top <= clientHeight / 2 && rect.bottom >= clientHeight / 2) {
                    centerPage = page;
                    break; 
                }
            }
            
            if (centerPage) {
                webtoonCurrentPage = parseInt(centerPage.dataset.page);
                if (webtoonCurrentPage !== currentPage) {
                    currentPage = webtoonCurrentPage;
                    updateProgress();
                    
                    // Save progress periodically (debounce)
                    clearTimeout(window.webtoonScrollTimeout);
                    window.webtoonScrollTimeout = setTimeout(() => {
                        saveProgress();
                    }, 1000);
                }
            }

            // Load more pages when near bottom
            if (scrollHeight - scrollTop - clientHeight < 1500) {
                const lastLoadedPage = Math.max(...webtoonLoadedPages);
                if (lastLoadedPage < pageCount - 1 && !webtoonLoading) {
                    // Load next batch
                    loadWebtoonPages(lastLoadedPage + 1, Math.min(lastLoadedPage + 6, pageCount));
                }
            }
        }

        // ========== NAVIGATION FUNCTIONS ==========

        async function navigateToNextComic() {
            showDoubleTapMessage('ë‹¤ìŒ ë§Œí™”ì±…ìœ¼ë¡œ ì´ë™ ì¤‘...');

            try {
                // Get current comic info
                const response = await fetch(`/api/comics/info/${fileId}`);
                const data = await response.json();

                if (!data.success) {
                    showDoubleTapMessage('ë§Œí™”ì±… ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                const currentSeries = data.data.series;
                const currentVolume = data.data.volume;

                if (!currentSeries || !currentVolume) {
                    showDoubleTapMessage('ë‹¤ìŒ ë§Œí™”ì±…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                // Find next volume in series
                const seriesResponse = await fetch(`/api/comics/series/${userId}/${encodeURIComponent(currentSeries)}`);
                const seriesData = await seriesResponse.json();

                if (!seriesData.success) {
                    showDoubleTapMessage('ì‹œë¦¬ì¦ˆ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                // Find next volume
                const comics = seriesData.comics;
                const nextComic = comics.find(c => c.volume === currentVolume + 1);

                if (nextComic) {
                    window.location.href = `/comic_reader/${nextComic.file_id}?user_id=${userId}`;
                } else {
                    showDoubleTapMessage('ë§ˆì§€ë§‰ ê¶Œì…ë‹ˆë‹¤');
                }

            } catch (error) {
                console.error('Error navigating to next comic:', error);
                showDoubleTapMessage('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
            }
        }

        async function navigateToPreviousComic() {
            try {
                const response = await fetch(`/api/comics/info/${fileId}`);
                const data = await response.json();

                if (!data.success) return;

                const currentSeries = data.data.series;
                const currentVolume = data.data.volume;

                if (!currentSeries || !currentVolume || currentVolume <= 1) return;

                const seriesResponse = await fetch(`/api/comics/series/${userId}/${encodeURIComponent(currentSeries)}`);
                const seriesData = await seriesResponse.json();

                if (!seriesData.success) return;

                const comics = seriesData.comics;
                const prevComic = comics.find(c => c.volume === currentVolume - 1);

                if (prevComic) {
                    window.location.href = `/comic_reader/${prevComic.file_id}?user_id=${userId}`;
                }
            } catch (error) {
                console.error('Error navigating to previous comic:', error);
            }
        }

        // ========== UI FUNCTIONS ==========

        function updateProgress() {
            const percent = pageCount > 0 ? (currentPage / (pageCount - 1)) * 100 : 0;
            progressBar.style.width = percent + '%';
            updatePageInfo();
        }

        // í™”ë©´ ë°©í–¥ ë³€ê²½ ê°ì§€
        window.addEventListener('resize', handleOrientationChange);
        window.addEventListener('orientationchange', handleOrientationChange);

        function handleOrientationChange() {
            // ë§Œí™”ì±… ëª¨ë“œì´ê³  í˜ì´ì§€ê°€ ë¡œë“œëœ ê²½ìš°ì—ë§Œ ì¬í‰ê°€
            if (mode === 'comic' && originalImageData) {
                // í˜„ì¬ í˜ì´ì§€ ë‹¤ì‹œ ë¡œë“œí•˜ì—¬ ì´ì¤‘ í˜ì´ì§€ ì—¬ë¶€ ì¬íŒë‹¨
                const savedPage = currentPage;
                const savedSplit = currentSplit;

                setTimeout(() => {
                    loadPage(savedPage, isDoublePage ? savedSplit : null);
                }, 300); // í™”ë©´ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸°
            }
        }

        function saveProgress() {
            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì‹œë¦¬ì¦ˆ ì„¤ì • ì €ì¥
            const currentSettings = {
                reading_direction: readingDirection,
                mode: mode,
                auto_split: autoSplitEnabled
            };
            try {
                localStorage.setItem(storageKey, JSON.stringify(currentSettings));
            } catch (e) { console.error("LocalStorage save error", e); }

            // ì„œë²„ì— ì§„í–‰ ìƒí™© ë° ì„¤ì • ì €ì¥
            fetch('/api/comics/progress', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    user_id: userId,
                    file_id: fileId,
                    current_page: currentPage,
                    settings: currentSettings
                })
            }).then(res => res.json())
              .then(data => {
                  if (data.success) {
                      console.log('Progress saved');
                  }
              })
              .catch(err => console.error('Failed to save progress', err));
        }

        function toggleMenu() {
            const controls = document.getElementById('controls');
            const settings = document.getElementById('settings');

            if (controls.classList.contains('active')) {
                controls.classList.remove('active');
                settings.classList.remove('active');
            } else {
                controls.classList.add('active');
                settings.classList.add('active');
            }
        }

        function toggleSettings() {
            document.getElementById('settings').classList.toggle('active');
        }

        function setReadingDirection(dir) {
            readingDirection = dir;
            document.querySelectorAll('[id^="dir-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('dir-' + dir).classList.add('active');
            saveProgress();

            // Swap touch zones for RTL
            if (dir === 'rtl') {
                document.getElementById('prev-zone').style.left = 'auto';
                document.getElementById('prev-zone').style.right = '0';
                document.getElementById('next-zone').style.right = 'auto';
                document.getElementById('next-zone').style.left = '0';
            } else {
                document.getElementById('prev-zone').style.left = '0';
                document.getElementById('prev-zone').style.right = 'auto';
                document.getElementById('next-zone').style.left = 'auto';
                document.getElementById('next-zone').style.right = '0';
            }
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('[id^="mode-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('mode-' + newMode).classList.add('active');
            saveProgress();

            if (newMode === 'webtoon') {
                viewer.classList.remove('comic-mode');
                viewer.classList.add('webtoon-mode');
                
                // ì›¹íˆ° ëª¨ë“œ: HTML/Body ìŠ¤í¬ë¡¤ í™œì„±í™”
                document.documentElement.classList.add('webtoon-mode-active');
                document.body.classList.add('webtoon-mode-active');
                
                // ì¢Œìš° í„°ì¹˜ ì¡´ ìˆ¨ê¹€
                document.getElementById('prev-zone').style.display = 'none';
                document.getElementById('next-zone').style.display = 'none';
                
                initWebtoonMode();
            } else {
                viewer.classList.remove('webtoon-mode');
                viewer.classList.add('comic-mode');
                
                // ë§Œí™”ì±… ëª¨ë“œ: HTML/Body ìŠ¤í¬ë¡¤ ì ê¸ˆ (ê¸°ë³¸ CSS)
                document.documentElement.classList.remove('webtoon-mode-active');
                document.body.classList.remove('webtoon-mode-active');
                
                // í„°ì¹˜ ì¡´ ë³µêµ¬
                document.getElementById('prev-zone').style.display = 'block';
                document.getElementById('next-zone').style.display = 'block';
                
                loadPage(currentPage);
            }
        }

        function applySettings() {
            setReadingDirection(readingDirection);
            document.querySelectorAll('[id^="mode-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('mode-' + mode).classList.add('active');

            // ìë™ ë¶„í•  ì„¤ì • ì ìš©
            document.querySelectorAll('[id^="split-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('split-' + (autoSplitEnabled ? 'on' : 'off')).classList.add('active');

            if (mode === 'webtoon') {
                viewer.classList.remove('comic-mode');
                viewer.classList.add('webtoon-mode');
                
                // í˜ì´ì§€ ë¡œë“œ ì‹œì—ë„ ì›¹íˆ° ëª¨ë“œë©´ Body ìŠ¤í¬ë¡¤ í™œì„±í™”
                document.documentElement.classList.add('webtoon-mode-active');
                document.body.classList.add('webtoon-mode-active');
                
                // í„°ì¹˜ ì¡´ ìˆ¨ê¹€
                document.getElementById('prev-zone').style.display = 'none';
                document.getElementById('next-zone').style.display = 'none';
            }
        }

        function setAutoSplit(enabled) {
            autoSplitEnabled = enabled;
            document.querySelectorAll('[id^="split-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('split-' + (enabled ? 'on' : 'off')).classList.add('active');
            saveProgress();

            // í˜„ì¬ í˜ì´ì§€ ë‹¤ì‹œ ë¡œë“œ
            if (mode === 'comic') {
                loadPage(currentPage);
            }
        }

        function showDoubleTapMessage(message = 'ë‹¤ìŒ ë§Œí™”ì±…ìœ¼ë¡œ ì´ë™') {
            const msg = document.getElementById('double-tap-message');
            msg.textContent = message;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 1500);
        }

        // ========== FAVORITE FUNCTIONS ==========

        async function loadFavoriteStatus() {
            try {
                const response = await fetch(`/api/comics/favorite/${fileId}?user_id=${userId}`);
                const data = await response.json();
                if (data.success && data.is_favorite) {
                    isFavorite = true;
                    document.getElementById('favorite-btn').textContent = 'â˜…';
                    document.getElementById('favorite-btn').classList.add('active');
                }
            } catch (error) {
                console.error('Error loading favorite status:', error);
            }
        }

        async function toggleFavorite() {
            try {
                const url = isFavorite ? '/api/comics/unfavorite' : '/api/comics/favorite';
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        user_id: userId,
                        file_id: fileId
                    })
                });

                const data = await response.json();
                if (data.success) {
                    isFavorite = !isFavorite;
                    const btn = document.getElementById('favorite-btn');
                    btn.textContent = isFavorite ? 'â˜…' : 'â˜†';
                    if (isFavorite) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            } catch (error) {
                console.error('Error toggling favorite:', error);
            }
        }

        // ========== DOWNLOAD FUNCTION ==========

        function downloadComic() {
            const downloadUrl = `/api/comics/download/${fileId}?user_id=${userId}`;
            window.location.href = downloadUrl;
        }

        // Pinch to zoom support (basic) for Comic Mode
        let scale = 1;
        let lastDistance = 0;

        pageImg.addEventListener('touchstart', handleTouchStart, {passive: true});
        pageImg.addEventListener('touchmove', handleTouchMove, {passive: false});

        function handleTouchStart(e) {
            if (e.touches.length === 2 && mode === 'comic') {
                lastDistance = getDistance(e.touches[0], e.touches[1]);
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2 && mode === 'comic') {
                e.preventDefault();
                const distance = getDistance(e.touches[0], e.touches[1]);
                const delta = distance - lastDistance;

                scale += delta * 0.01;
                scale = Math.min(Math.max(scale, 1), 5);

                pageImg.style.transform = `scale(${scale})`;
                lastDistance = distance;

                if (scale > 1) {
                    viewer.classList.add('zoomed');
                } else {
                    viewer.classList.remove('zoomed');
                }
            }
        }

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ========== BOOKMARKS & SERIES FUNCTIONS ==========

        let isCompleted = false;

        // Load completion status on page load
        async function loadCompletion() {
            try {
                isCompleted = await getCompletionStatus(fileId, 'comic');
                const btn = document.getElementById('completion-btn');
                if (isCompleted) {
                    btn.classList.add('active');
                    btn.style.color = '#4CAF50';
                } else {
                    btn.classList.remove('active');
                    btn.style.color = '#fff';
                }
            } catch (error) {
                console.error('Error loading completion status:', error);
            }
        }

        // Toggle completion status
        async function toggleComicCompletion() {
            const newStatus = await toggleCompletion(fileId, 'comic', isCompleted);
            if (newStatus !== null) {
                isCompleted = newStatus;
                const btn = document.getElementById('completion-btn');
                if (isCompleted) {
                    btn.classList.add('active');
                    btn.style.color = '#4CAF50';
                } else {
                    btn.classList.remove('active');
                    btn.style.color = '#fff';
                }
            }
        }

        // Add bookmark at current page
        async function addBookmarkClick() {
            const title = prompt('ë¶ë§ˆí¬ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”:', `${currentPage + 1}í˜ì´ì§€`);
            if (!title) return;

            const note = prompt('ë©”ëª¨ (ì„ íƒ):', '');

            const position = {
                page: currentPage
            };

            const bookmark = await createBookmark(fileId, 'comic', position, title, note);
            if (bookmark) {
                alert('ë¶ë§ˆí¬ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!');
                loadBookmarksPanel();
            }
        }

        // Toggle bookmarks panel
        function toggleBookmarksPanel() {
            const panel = document.getElementById('bookmarks-panel');
            if (panel.classList.contains('active')) {
                panel.classList.remove('active');
            } else {
                panel.classList.add('active');
                loadBookmarksPanel();
            }
        }

        // Load bookmarks list
        async function loadBookmarksPanel() {
            const listDiv = document.getElementById('bookmarks-list');
            listDiv.innerHTML = '<p style="color: #888; text-align: center;">ë¡œë”© ì¤‘...</p>';

            const bookmarks = await getBookmarks(fileId, 'comic');

            if (bookmarks.length === 0) {
                listDiv.innerHTML = '<p style="color: #888; text-align: center;">ë¶ë§ˆí¬ê°€ ì—†ìŠµë‹ˆë‹¤</p>';
                return;
            }

            listDiv.innerHTML = bookmarks.map(b => `
                <div style="padding: 15px; margin-bottom: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; cursor: pointer;"
                     onclick="goToBookmark(${b.bookmark_position.page})">
                    <div style="font-weight: bold; margin-bottom: 5px;">${b.title}</div>
                    ${b.note ? `<div style="font-size: 13px; color: #aaa; margin-bottom: 5px;">${b.note}</div>` : ''}
                    <div style="font-size: 12px; color: #667eea;">í˜ì´ì§€ ${b.bookmark_position.page + 1}</div>
                    <button onclick="event.stopPropagation(); deleteBookmarkClick(${b.id})"
                            style="margin-top: 8px; padding: 4px 12px; background: #e74c3c; color: #fff; border: none; border-radius: 4px; cursor: pointer;">
                        ì‚­ì œ
                    </button>
                </div>
            `).join('');
        }

        // Go to bookmarked page
        function goToBookmark(page) {
            toggleBookmarksPanel();
            if (mode === 'comic') {
                loadPage(page);
            } else {
                // Webtoon mode: scroll to page
                const pageDiv = document.querySelector(`.webtoon-page[data-page="${page}"]`);
                if (pageDiv) {
                    pageDiv.scrollIntoView({ behavior: 'smooth' });
                }
            }
        }

        // Delete bookmark
        async function deleteBookmarkClick(bookmarkId) {
            if (!confirm('ì´ ë¶ë§ˆí¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            const success = await deleteBookmark(bookmarkId);
            if (success) {
                loadBookmarksPanel();
            }
        }

        // Show series selection modal
        function showSeriesModal() {
            showSeriesSelectionModal(fileId, 'comic');
        }

        // Load completion status on page load
        loadCompletion();
    </script>
</body>
</html>
